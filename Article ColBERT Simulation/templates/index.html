<!DOCTYPE html>
<html>
<head>
    <title>ColBERT Architecture Simulation</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Enhanced Header Styles */
        header {
            background: linear-gradient(135deg, #1E40AF, #3B82F6);
            padding: 3rem 0;
            position: relative;
            overflow: hidden;
            border-radius: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* Navigation Button Styles */
        .nav-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        /* Language Switch Styles */
        .language-switch {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
        }

        .lang-button {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .lang-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .lang-button.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        .header-title {
            font-size: 3rem;
            font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header-subtitle {
            font-size: 1.25rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 1rem auto;
        }

        /* Enhanced Section Styles */
        section {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }
        
        section:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        /* Visualization Container Styles */
        .visualization-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }

        .architecture {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            position: relative;
            min-height: 600px;
            overflow: hidden;
        }

        /* Component Box Styles */
        .component-box {
            fill: #e0f2f7;
            stroke: #0d47a1;
            stroke-width: 2px;
            rx: 8;
            ry: 8;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .component-box:hover {
            stroke: #1565c0;
            fill: #bbdefb;
            filter: brightness(1.05);
        }

        .component-box.active {
            fill: #1e88e5;
            stroke: #0d47a1;
            stroke-width: 3px;
            filter: brightness(1.1);
        }

        /* Node Type Specific Styles */
        .node-input, .node-output {
            fill: #e8f5e9;
            stroke: #2e7d32;
        }

        .node-input:hover, .node-output:hover {
            fill: #c8e6c9;
            stroke: #388e3c;
        }

        .node-processing {
            fill: #fff3e0;
            stroke: #ef6c00;
        }

        .node-processing:hover {
            fill: #ffe0b2;
            stroke: #f57c00;
        }

        .node-parallel {
            fill: #ede7f6;
            stroke: #5e35b1;
        }

        .node-parallel:hover {
            fill: #d1c4e9;
            stroke: #673ab7;
        }

        /* Component Text Styles */
        .component-text {
            font-size: 0.9rem;
            text-anchor: middle;
            fill: #1e293b;
            font-weight: 500;
            pointer-events: none;
        }

        /* Link Styles */
        .link {
            stroke: #90a4ae;
            stroke-width: 2px;
            transition: all 0.3s ease;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .link.active {
            stroke: #1a73e8;
            stroke-width: 3px;
            stroke-dasharray: 10, 5;
            animation: flow 1s linear infinite;
        }

        .link.active marker-end path {
            fill: #1a73e8;
        }

        /* Link Label Styles */
        .link-label {
            font-size: 0.8rem;
            fill: #455a64;
            text-anchor: middle;
            pointer-events: none;
            transition: fill 0.3s ease;
        }

        .link-label.active {
            fill: #1e40af;
            font-weight: bold;
        }

        /* Controls Section Styles */
        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }

        /* Step Details Styles */
        .step-details {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        /* Enhanced Textarea Styles */
        textarea {
            width: 100%;
            height: 120px;
            padding: 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 0.5rem;
            font-size: 1rem;
            resize: vertical;
            transition: all 0.3s ease;
            background: linear-gradient(to bottom, #f8fafc, #f1f5f9);
        }

        textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Enhanced Button Styles */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3B82F6, #2563EB);
            color: white;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Enhanced Tooltip Styles */
        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, #1E293B, #334155);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            line-height: 1.5;
        }

        /* Enhanced Control Button Styles */
        .control-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #F0FDF4, #DCFCE7);
            border: 2px solid #10B981;
            color: #10B981;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, #DCFCE7, #BBF7D0);
        }

        .control-button:active {
            transform: translateY(0);
        }

        /* Enhanced Popup Styles */
        #step-popup {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        #step-popup .bg-white {
            background: linear-gradient(135deg, #ffffff, #f8fafc);
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* Enhanced Footer Styles */
        footer {
            background: linear-gradient(135deg, #1E293B, #334155);
            color: white;
            padding: 2rem 0;
            margin-top: 4rem;
            border-radius: 1rem;
        }

        /* Loading Animation */
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Data Path Animation */
        .data-path {
            stroke-dasharray: 5,5;
            animation: flow 1s linear infinite;
        }

        @keyframes flow {
            to {
                stroke-dashoffset: -10;
            }
        }
    </style>
</head>
<body class="min-h-screen">
    <div class="container">
        <header>
            <a href="/" class="nav-button">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
                Back to Home
            </a>
            <div class="language-switch">
                <button class="lang-button active" onclick="switchLanguage('en')">EN</button>
                <button class="lang-button" onclick="switchLanguage('fr')">FR</button>
            </div>
            <div class="header-content text-center">
                <h1 class="header-title text-white mb-4">ColBERT Architecture Simulation</h1>
                <p class="header-subtitle text-white">Interactive visualization of the ColBERT model's text processing pipeline</p>
            </div>
        </header>
        
        <main>
            <section id="input-section">
                <div class="mb-4">
                    <label for="input-text" class="block text-sm font-medium text-gray-700 mb-2">Enter your text for humor detection:</label>
                    <textarea id="input-text" class="w-full" placeholder="Example: Is the doctor at home? No, come right in.">Is the doctor at home? No, come right in.</textarea>
                </div>
                <button onclick="processText()" class="btn">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                    </svg>
                    Process Text
                </button>
            </section>
            
            <section id="visualization-section">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">ColBERT Architecture</h2>
                <p class="text-gray-600 mb-6">Hover over the components below to learn more about each step in the ColBERT model's text processing pipeline. Click on a component to see the details of the processing step associated with it.</p>
                <div class="architecture" id="architecture">
                    <div class="loading">
                        <div class="spinner"></div>
                    </div>
                    <div class="tooltip" style="display: none;"></div>
                </div>
            </section>

            <!-- Processing Steps Pop-up -->
            <div id="step-popup" class="fixed inset-0 flex items-center justify-center z-50 hidden">
                <div class="bg-white rounded-lg p-6 max-w-2xl w-full shadow-xl">
                    <div class="flex justify-between items-center mb-4">
                        <h3 id="popup-title" class="text-xl font-bold text-gray-800"></h3>
                        <button onclick="closePopup()" class="text-gray-500 hover:text-gray-800 focus:outline-none">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                    <div id="popup-description" class="text-gray-600 mb-4"></div>
                    <div id="popup-details" class="step-details"></div>
                </div>
            </div>

            <section id="controls-section" class="controls">
                <button class="control-button" onclick="previousStep()">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                    Previous Step
                </button>
                <button class="control-button" onclick="nextStep()">
                    Next Step
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                    </svg>
                </button>
                <button class="control-button" onclick="resetSimulation()">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                    </svg>
                    Reset
                </button>
            </section>
        </main>

      
    </div>

    <script>
        // Architecture graph data with enhanced descriptions and positions based on the image
        const nodes = [
            { 
                id: 'input', 
                label: 'Input Text', 
                x: 100, // Adjusted position
                y: 250, 
                description: 'Raw text input containing two sentences for humor detection',
                width: 120,
                height: 60,
                type: 'input',
                step: 1 // Link to corresponding step
            },
            { 
                id: 'tokenizer', 
                label: 'Tokenizer', 
                x: 250, // Adjusted position
                y: 250, 
                description: 'Splits text into tokens and adds special tokens ([CLS], [SEP])',
                width: 120,
                height: 60,
                type: 'processing',
                step: 2 // Link to corresponding step
            },
            { 
                id: 'bert', 
                label: 'BERT Encoder', 
                x: 400, // Adjusted position
                y: 250, 
                description: '12-layer transformer model generating contextual embeddings',
                width: 120,
                height: 60,
                type: 'processing',
                step: 3 // Link to corresponding step
            },
            {
                id: 'sentence_path1',
                label: 'Sentence Path 1',
                x: 650, // Adjusted position
                y: 100, // Adjusted position
                description: 'Processes first sentence embedding through parallel neural network',
                width: 180, // Increased width for label
                height: 60,
                type: 'parallel',
                step: 4 // Link to corresponding step
            },
            {
                id: 'sentence_path2',
                label: 'Sentence Path 2',
                x: 650, // Adjusted position
                y: 400, // Adjusted position
                description: 'Processes second sentence embedding through parallel neural network',
                width: 180, // Increased width for label
                height: 60,
                type: 'parallel',
                step: 4 // Link to corresponding step
            },
            {
                id: 'text_path',
                label: 'Whole Text Path', // Adjusted label for clarity
                x: 650, // Adjusted position
                y: 250, // Adjusted position
                description: 'Processes whole text embedding through parallel neural network',
                width: 180, // Increased width for label
                height: 60,
                type: 'parallel',
                step: 4 // Link to corresponding step
            },
            { 
                id: 'concat', 
                label: 'Feature Integration', 
                x: 900, // Adjusted position
                y: 250, // Adjusted position
                description: 'Combines features from all paths for final processing',
                width: 140, // Adjusted width
                height: 60,
                type: 'processing',
                step: 5 // Link to corresponding step
            },
            { 
                id: 'final', 
                label: 'Final Layers', 
                x: 1050, // Adjusted position
                y: 250, // Adjusted position
                description: 'Three dense layers for final classification',
                width: 120,
                height: 60,
                type: 'processing',
                step: 5 // Link to corresponding step
            },
            { 
                id: 'output', 
                label: 'Humor Detection', 
                x: 1200, // Adjusted position
                y: 250, // Adjusted position
                description: 'Outputs probability of text being humorous',
                width: 140, // Adjusted width
                height: 60,
                type: 'output',
                step: 5 // Link to corresponding step
            }
        ];

        const links = [
            { source: 'input', target: 'tokenizer', label: 'Text Input' },
            { source: 'tokenizer', target: 'bert', label: 'Tokenized Text' },
            { source: 'bert', target: 'sentence_path1', label: 'Sentence 1 Embedding' },
            { source: 'bert', target: 'sentence_path2', label: 'Sentence 2 Embedding' },
            { source: 'bert', target: 'text_path', label: 'Whole Text Embedding' },
            { source: 'sentence_path1', target: 'concat', label: 'Sentence 1 Features' },
            { source: 'sentence_path2', target: 'concat', label: 'Sentence 2 Features' },
            { source: 'text_path', target: 'concat', label: 'Text Features' },
            { source: 'concat', target: 'final', label: 'Combined Features' },
            { source: 'final', target: 'output', label: 'Humor Probability' } // Adjusted label
        ];

        let currentStep = 0;
        let currentSteps = [];
        let animationInProgress = false;

        // Create SVG container. Ensure it's large enough for the new layout.
        const svg = d3.select('#architecture')
            .append('svg')
            .attr('width', 1300) // Increased width
            .attr('height', 500); // Increased height

        // Create component boxes (rectangles)
        const componentBox = svg.selectAll('.component-box')
            .data(nodes)
            .enter()
            .append('rect')
            .attr('class', d => 'component-box node-' + d.type)
            .attr('x', d => d.x - d.width/2)
            .attr('y', d => d.y - d.height/2)
            .attr('width', d => d.width)
            .attr('height', d => d.height);

        // Create links (paths)
        const link = svg.selectAll('.link')
            .data(links)
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('d', d => {
                const source = nodes.find(n => n.id === d.source);
                const target = nodes.find(n => n.id === d.target);
                
                // Custom path for diagonal links from BERT to parallel paths
                if (d.source === 'bert' && d.target === 'sentence_path1') {
                     return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`; // Connect from right of BERT to left of Sentence Path 1
                } else if (d.source === 'bert' && d.target === 'sentence_path2') {
                     return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`; // Connect from right of BERT to left of Sentence Path 2
                } else if (d.source === 'bert' && d.target === 'text_path') {
                     return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`; // Connect from right of BERT to left of Text Path
                } else if (d.source === 'sentence_path1' && d.target === 'concat') {
                     return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`; // Connect from right of Sentence Path 1 to left of Concat
                } else if (d.source === 'sentence_path2' && d.target === 'concat') {
                     return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`; // Connect from right of Sentence Path 2 to left of Concat
                } else if (d.source === 'text_path' && d.target === 'concat') {
                     return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`; // Connect from right of Text Path to left of Concat
                } 
                 // Default path for horizontal links
                return `M${source.x + source.width/2},${source.y}L${target.x - target.width/2},${target.y}`;
            })
            .attr('marker-end', 'url(#arrowhead)'); // Add arrowhead marker

        // Add link labels
        const linkLabel = svg.selectAll('.link-label')
            .data(links)
            .enter()
            .append('text')
            .attr('class', 'link-label') // Use link-label class
            .attr('x', d => {
                const source = nodes.find(n => n.id === d.source);
                const target = nodes.find(n => n.id === d.target);
                return (source.x + source.width/2 + target.x - target.width/2) / 2; // Position label in the middle of the link
            })
            .attr('y', d => {
                const source = nodes.find(n => n.id === d.source);
                const target = nodes.find(n => n.id === d.target);
                return (source.y + target.y) / 2 - 5; // Offset label slightly above the link
            })
            .text(d => d.label);

        // Add component labels (inside the boxes)
        const componentLabel = svg.selectAll('.component-label')
            .data(nodes)
            .enter()
            .append('text')
            .attr('class', 'component-text')
            .attr('x', d => d.x) // Position label at the center of the box
            .attr('y', d => d.y + 5) // Adjust vertical position
            .text(d => d.label);

        // Add arrowhead marker definition
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '-0 -5 10 10')
            .attr('refX', 10) // Position arrowhead at the end of the path
            .attr('refY', 0)
            .attr('orient', 'auto')
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('xoverflow','visible')
            .append('svg:path')
            .attr('d', 'M 0, -5 L 10, 0 L 0, 5 Z')
            .attr('fill', '#999') // Default arrowhead color
            .style('stroke','none');

        // Add hover effects
        componentBox
            .on('mouseover', showTooltip)
            .on('mouseout', hideTooltip);

        function showTooltip(event, d) {
            const tooltip = d3.select('.tooltip');
            tooltip.style('display', 'block')
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .html(`
                    <div class="font-bold mb-2">${d.label}</div>
                    <div class="text-sm text-gray-300">${d.description}</div>
                `);
        }

        function hideTooltip() {
            d3.select('.tooltip').style('display', 'none');
        }

        function processText() {
            const loading = document.querySelector('.loading');
            loading.classList.add('active');
            
            const text = document.getElementById('input-text').value;
            fetch(`/process/${encodeURIComponent(text)}`)
                .then(response => response.json())
                .then(steps => {
                    currentSteps = steps;
                    currentStep = 0;
                    displaySteps(steps);
                    highlightStep(steps[0]);
                    loading.classList.remove('active');
                })
                .catch(error => {
                    console.error('Error:', error);
                    loading.classList.remove('active');
                });
        }

        function displaySteps(steps) {
            currentSteps = steps; // Store the steps globally
            // Hide the original steps section
            document.getElementById('steps-section').classList.add('hidden');
             // No longer rendering the list here
        }

        // Add language switch functionality
        let currentLanguage = 'en';

        function switchLanguage(lang) {
            currentLanguage = lang;
            const buttons = document.querySelectorAll('.lang-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update the UI with the new language
            updateLanguageUI();
        }

        function updateLanguageUI() {
            // Update header text
            document.querySelector('.header-title').textContent = currentLanguage === 'en' ? 
                'ColBERT Architecture Simulation' : 'Simulation de l\'Architecture ColBERT';
            document.querySelector('.header-subtitle').textContent = currentLanguage === 'en' ?
                'Interactive visualization of the ColBERT model\'s text processing pipeline' :
                'Visualisation interactive du pipeline de traitement de texte du modèle ColBERT';

            // Update input section
            document.querySelector('label[for="input-text"]').textContent = currentLanguage === 'en' ?
                'Enter your text for humor detection:' : 'Entrez votre texte pour la détection d\'humour:';
            document.getElementById('input-text').placeholder = currentLanguage === 'en' ?
                'Example: Is the doctor at home? No, come right in.' :
                'Exemple: Le docteur est-il à la maison ? Non, entrez.';
            document.querySelector('.btn').innerHTML = currentLanguage === 'en' ?
                '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>Process Text' :
                '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>Traiter le Texte';

            // Update visualization section
            document.querySelector('#visualization-section h2').textContent = currentLanguage === 'en' ?
                'ColBERT Architecture' : 'Architecture ColBERT';
            document.querySelector('#visualization-section p').textContent = currentLanguage === 'en' ?
                'Hover over the components below to learn more about each step in the ColBERT model\'s text processing pipeline. Click on a component to see the details of the processing step associated with it.' :
                'Survolez les composants ci-dessous pour en savoir plus sur chaque étape du pipeline de traitement de texte du modèle ColBERT. Cliquez sur un composant pour voir les détails de l\'étape de traitement associée.';

            // Update controls
            const controls = document.querySelectorAll('.control-button');
            controls[0].innerHTML = currentLanguage === 'en' ?
                '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>Previous Step' :
                '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>Étape Précédente';
            controls[1].innerHTML = currentLanguage === 'en' ?
                'Next Step<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>' :
                'Étape Suivante<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>';
            controls[2].innerHTML = currentLanguage === 'en' ?
                '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>Reset' :
                '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>Réinitialiser';

            // Update popup content if it's open
            const popup = document.getElementById('step-popup');
            if (!popup.classList.contains('hidden')) {
                const currentStep = currentSteps[currentStep];
                if (currentStep) {
                    openPopup(currentStep);
                }
            }
        }

        // Add step titles and descriptions
        const stepInfo = {
            en: {
                1: {
                    title: "Text Input Processing",
                    description: "Initial text processing and sentence segmentation"
                },
                2: {
                    title: "Tokenization",
                    description: "Converting text into tokens for BERT processing"
                },
                3: {
                    title: "BERT Encoding",
                    description: "Generating contextual embeddings using BERT"
                },
                4: {
                    title: "Parallel Processing",
                    description: "Feature extraction through parallel neural networks"
                },
                5: {
                    title: "Final Classification",
                    description: "Combining features and making the final prediction"
                }
            },
            fr: {
                1: {
                    title: "Traitement du Texte d'Entrée",
                    description: "Traitement initial du texte et segmentation des phrases"
                },
                2: {
                    title: "Tokenisation",
                    description: "Conversion du texte en tokens pour le traitement BERT"
                },
                3: {
                    title: "Encodage BERT",
                    description: "Génération d'embeddings contextuels avec BERT"
                },
                4: {
                    title: "Traitement Parallèle",
                    description: "Extraction de caractéristiques via des réseaux neuronaux parallèles"
                },
                5: {
                    title: "Classification Finale",
                    description: "Combinaison des caractéristiques et prédiction finale"
                }
            }
        };

        function getStepRole(stepNumber) {
            const roles = {
                en: {
                    1: "This initial step prepares the raw text input for the model by breaking it down into fundamental units.",
                    2: "Transforms the segmented sentences into a format that the BERT model can understand and process.",
                    3: "Creates rich, contextual vector representations (embeddings) for both individual sentences and the entire text.",
                    4: "Analyzes the sentence and whole-text embeddings through specialized pathways to extract relevant features.",
                    5: "Concatenation Layer: Combines features from different pathways. Final Layers: Processes the combined features to make the final humor prediction."
                },
                fr: {
                    1: "Cette étape initiale prépare le texte brut pour le modèle en le décomposant en unités fondamentales.",
                    2: "Transforme les phrases segmentées dans un format que le modèle BERT peut comprendre et traiter.",
                    3: "Crée des représentations vectorielles contextuelles riches (embeddings) pour les phrases individuelles et le texte entier.",
                    4: "Analyse les embeddings des phrases et du texte entier à travers des chemins spécialisés pour extraire des caractéristiques pertinentes.",
                    5: "Couche de Concaténation: Combine les caractéristiques des différents chemins. Couches Finales: Traite les caractéristiques combinées pour faire la prédiction finale d'humour."
                }
            };
            return roles[currentLanguage][stepNumber] || "";
        }

        function getStepProcess(stepNumber) {
            const processes = {
                en: {
                    1: "The input text is first cleaned (e.g., removing extra spaces) and then accurately split into individual sentences using advanced natural language processing techniques like NLTK's sentence tokenizer.\n\nExample:\nInput: \"Is the doctor at home? No, come right in.\"\nOutput: [\"Is the doctor at home?\"] , [\"No, come right in.\"]",
                    2: "Each sentence string is converted into a sequence of tokens (words, subwords, punctuation). Special tokens like [CLS] (for classification) and [SEP] (separator) are added at the beginning and end, respectively.\n\nExample (for 'Is the doctor at home?'):\nInput: \"Is the doctor at home?\"\nOutput: [\'[CLS]\', \'is\', \'the\', \'doctor\', \'at\', \'home\', \'?\', \'[SEP]\']",
                    3: "The tokenized sentences and the whole text are fed into the BERT (Bidirectional Encoder Representations from Transformers) model. BERT processes the text bidirectionally through 12 transformer layers to generate a fixed-size (768-dimensional) vector for each, capturing complex contextual relationships.\n\nExample:\nInput (tokenized sentence): [\'[CLS]\', \'is\', \'the\', \'doctor\', \'at\', \'home\', \'?\', \'[SEP]\']\nOutput (sentence embedding): A 768-dimensional vector (e.g., [-0.12, 0.55, ..., 0.91])",
                    4: "The 768-dimensional embeddings from BERT for Sentence 1, Sentence 2, and the Whole Text are passed through separate, smaller neural network pathways (Sentence Path 1, Sentence Path 2, and Whole Text Path). Each path consists of dense layers with ReLU activation, reducing the dimensionality and extracting specific features related to each input.\n\nExample (Dimensionality Reduction):\nSentence 1 Embedding (768D) → Sentence Path 1 → Sentence 1 Features (20D)\nSentence 2 Embedding (768D) → Sentence Path 2 → Sentence 2 Features (20D)\nWhole Text Embedding (768D) → Whole Text Path → Text Features (60D)",
                    5: "Features extracted from the parallel pathways (Sentence 1 Features, Sentence 2 Features, Text Features) are concatenated into a single, combined feature vector (20D + 20D + 60D = 100D). This comprehensive vector is then fed through the final layers, which are a series of dense layers (100 → 50 → 10 → 1 neurons) with ReLU activations (except for the final single neuron with a Sigmoid activation). The Sigmoid function outputs a value between 0 and 1, representing the probability of the text being humorous.\n\nExample (Feature Combination and Prediction):\nInput: Sentence 1 Features (20D), Sentence 2 Features (20D), Text Features (60D)\nProcess: Concatenation → Combined Features (100D) → Final Dense Layers → Sigmoid Activation\nOutput: Humor Probability (e.g., 0.95)"
                },
                fr: {
                    1: "Le texte d'entrée est d'abord nettoyé (par exemple, suppression des espaces supplémentaires) puis divisé avec précision en phrases individuelles en utilisant des techniques avancées de traitement du langage naturel comme le tokenizer de phrases NLTK.\n\nExemple:\nEntrée: \"Le docteur est-il à la maison ? Non, entrez.\"\nSortie: [\"Le docteur est-il à la maison ?\"] , [\"Non, entrez.\"]",
                    2: "Chaque chaîne de phrase est convertie en une séquence de tokens (mots, sous-mots, ponctuation). Des tokens spéciaux comme [CLS] (pour la classification) et [SEP] (séparateur) sont ajoutés respectivement au début et à la fin.\n\nExemple (pour 'Le docteur est-il à la maison ?'):\nEntrée: \"Le docteur est-il à la maison ?\"\nSortie: [\'[CLS]\', \'le\', \'docteur\', \'est\', \'-\', \'il\', \'à\', \'la\', \'maison\', \'?\', \'[SEP]\']",
                    3: "Les phrases tokenisées et le texte entier sont introduits dans le modèle BERT (Bidirectional Encoder Representations from Transformers). BERT traite le texte bidirectionnellement à travers 12 couches de transformateurs pour générer un vecteur de taille fixe (768 dimensions) pour chacun, capturant des relations contextuelles complexes.\n\nExemple:\nEntrée (phrase tokenisée): [\'[CLS]\', \'le\', \'docteur\', \'est\', \'-\', \'il\', \'à\', \'la\', \'maison\', \'?\', \'[SEP]\']\nSortie (embedding de phrase): Un vecteur de 768 dimensions (ex: [-0.12, 0.55, ..., 0.91])",
                    4: "Les embeddings de 768 dimensions de BERT pour la Phrase 1, la Phrase 2 et le Texte Entier passent par des chemins de réseau neuronal plus petits séparés (Chemin Phrase 1, Chemin Phrase 2 et Chemin Texte Entier). Chaque chemin consiste en des couches denses avec activation ReLU, réduisant la dimensionnalité et extrayant des caractéristiques spécifiques liées à chaque entrée.\n\nExemple (Réduction de Dimensionnalité):\nEmbedding Phrase 1 (768D) → Chemin Phrase 1 → Caractéristiques Phrase 1 (20D)\nEmbedding Phrase 2 (768D) → Chemin Phrase 2 → Caractéristiques Phrase 2 (20D)\nEmbedding Texte Entier (768D) → Chemin Texte Entier → Caractéristiques Texte (60D)",
                    5: "Les caractéristiques extraites des chemins parallèles (Caractéristiques Phrase 1, Caractéristiques Phrase 2, Caractéristiques Texte) sont concaténées en un seul vecteur de caractéristiques combiné (20D + 20D + 60D = 100D). Ce vecteur complet est ensuite traité par les couches finales, qui sont une série de couches denses (100 → 50 → 10 → 1 neurones) avec des activations ReLU (sauf pour le neurone final unique avec une activation Sigmoid). La fonction Sigmoid produit une valeur entre 0 et 1, représentant la probabilité que le texte soit humoristique.\n\nExemple (Combinaison de Caractéristiques et Prédiction):\nEntrée: Caractéristiques Phrase 1 (20D), Caractéristiques Phrase 2 (20D), Caractéristiques Texte (60D)\nProcessus: Concaténation → Caractéristiques Combinées (100D) → Couches Denses Finales → Activation Sigmoid\nSortie: Probabilité d'Humour (ex: 0.95)"
                }
            };
            return processes[currentLanguage][stepNumber] || "";
        }

        function getStepOutput(step) {
            const labels = {
                en: {
                    output: "Output:",
                    sentences: "Sentences:",
                    outputExample: "Output Example (First Sentence):",
                    humorProbability: "Humor Probability:",
                    above50: "A probability above 50% generally indicates the model predicts humor.",
                    role: "Role:",
                    process: "Process:"
                },
                fr: {
                    output: "Sortie:",
                    sentences: "Phrases:",
                    outputExample: "Exemple de Sortie (Première Phrase):",
                    humorProbability: "Probabilité d'Humour:",
                    above50: "Une probabilité supérieure à 50% indique généralement que le modèle prédit de l'humour.",
                    role: "Rôle:",
                    process: "Processus:"
                }
            };

            if (step.step === 1) {
                return `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].output}</h4>
                        <div class="bg-white p-3 rounded border border-gray-200 text-sm text-gray-600">
                            <p class="font-semibold mb-1">${labels[currentLanguage].sentences}</p>
                            <ul class="list-disc list-inside ml-4">
                                ${step.output.map((sent, i) => `<li>${sent}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                `;
            } else if (step.step === 2) {
                const exampleTokens = step.output.length > 0 ? step.output[0].slice(0, 10).join(', ') + (step.output[0].length > 10 ? ', ...' : '') : 'No tokens';
                return `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].outputExample}</h4>
                        <div class="bg-white p-3 rounded border border-gray-200 text-sm text-gray-600">
                             <p class="break-words">[${exampleTokens}]</p>
                        </div>
                    </div>
                `;
            } else if (step.step === 3) {
                return `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].output}</h4>
                        <div class="bg-white p-3 rounded border border-gray-200 text-sm text-gray-600">
                             <p>BERT generates high-dimensional embeddings for each sentence and the whole text.</p>
                             <p class="mt-1 font-semibold">Embedding Dimensions:</p>
                             <ul class="list-disc list-inside ml-4">
                                 <li>Sentence Embeddings: 768 dimensions each</li>
                                 <li>Whole Text Embedding: 768 dimensions</li>
                             </ul>
                        </div>
                    </div>
                `;
            } else if (step.step === 4) {
                return `
                     <div class="mt-4 pt-4 border-t border-gray-200">
                         <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].output}</h4>
                         <div class="bg-white p-3 rounded border border-gray-200 text-sm text-gray-600">
                              <p>Parallel networks extract features from embeddings.</p>
                              <p class="mt-1 font-semibold">Extracted Feature Dimensions:</p>
                              <ul class="list-disc list-inside ml-4">
                                  <li>Sentence 1 Features: 20 dimensions</li>
                                  <li>Sentence 2 Features: 20 dimensions</li>
                                  <li>Text Features: 60 dimensions</li>
                              </ul>
                         </div>
                     </div>
                 `;
            } else if (step.step === 5) {
                return `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].output}</h4>
                        <div class="bg-white p-3 rounded border border-gray-200 text-sm text-gray-600">
                            <div class="flex items-center justify-between mb-2">
                                <span class="font-semibold">${labels[currentLanguage].humorProbability}</span>
                                <span class="text-lg font-bold ${step.output.humor_probability > 0.5 ? 'text-green-600' : 'text-red-600'}">
                                    ${(step.output.humor_probability * 100).toFixed(1)}%
                                </span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5">
                                <div class="bg-blue-600 h-2.5 rounded-full" style="width: ${step.output.humor_probability * 100}%"></div>
                            </div>
                             <p class="mt-2 text-xs text-gray-500">${labels[currentLanguage].above50}</p>
                        </div>
                    </div>
                `;
            }
            return '';
        }

        function openPopup(step) {
            const popup = document.getElementById('step-popup');
            const labels = {
                en: {
                    role: "Role:",
                    process: "Process:"
                },
                fr: {
                    role: "Rôle:",
                    process: "Processus:"
                }
            };

            document.getElementById('popup-title').innerText = `Step ${step.step}: ${stepInfo[currentLanguage][step.step].title}`;
            document.getElementById('popup-description').innerText = stepInfo[currentLanguage][step.step].description;
            document.getElementById('popup-details').innerHTML = `
                <div class="bg-gray-50 p-4 rounded-lg text-gray-700">
                    <div class="mb-3">
                        <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].role}</h4>
                        <p class="text-sm text-gray-600">${getStepRole(step.step)}</p>
                    </div>
                    <div class="mb-3">
                        <h4 class="text-sm font-semibold text-gray-700 mb-1">${labels[currentLanguage].process}</h4>
                        <p class="text-sm text-gray-600">${getStepProcess(step.step)}</p>
                    </div>
                    ${getStepOutput(step)}
                </div>
            `;
            popup.classList.remove('hidden');
        }

        function closePopup() {
            document.getElementById('step-popup').classList.add('hidden');
        }

        function highlightStep(step) {
            if (animationInProgress) return;
            animationInProgress = true;

            // Reset all components and links with fade out
            componentBox
                .transition()
                .duration(300)
                .style('opacity', 0.5);
            componentBox.classed('active', false);

            link
                .interrupt() // Stop any ongoing animations
                .transition()
                .duration(300)
                .style('opacity', 0.5);
            link.classed('active', false);
            
            // Reset all link labels
            d3.selectAll('.link-label')
                .classed('active', false);
            
            // Animate the activation of components and links
            const activeNodes = step.active_nodes;
            
            // Determine active links based on active nodes and step number
            const activeLinks = links.filter(link => {
                const sourceIndex = activeNodes.indexOf(link.source);
                const targetIndex = activeNodes.indexOf(link.target);
                
                // Link is active if both source and target nodes are active
                // and the source appears before the target in the active_nodes list
                // This heuristic works for a generally left-to-right flow
                if (sourceIndex !== -1 && targetIndex !== -1 && sourceIndex < targetIndex) {
                    return true;
                }
                // Also consider specific links for certain steps if the general heuristic isn't enough
                if (step.step === 1 && link.source === 'input' && link.target === 'tokenizer') return true;
                if (step.step === 2 && link.source === 'tokenizer' && link.target === 'bert') return true;
                if (step.step === 3 && link.source === 'bert' && (link.target === 'sentence_path1' || link.target === 'sentence_path2' || link.target === 'text_path')) return true;
                if (step.step === 4 && (link.source === 'sentence_path1' || link.source === 'sentence_path2' || link.source === 'text_path') && link.target === 'concat') return true;
                if (step.step === 5 && link.source === 'concat' && link.target === 'final') return true;
                if (step.step === 5 && link.source === 'final' && link.target === 'output') return true;

                return false;
            });

            // Animate components with fade in
            activeNodes.forEach((nodeId, index) => {
                setTimeout(() => {
                    componentBox
                        .filter(d => d.id === nodeId)
                        .transition()
                        .duration(300)
                        .style('opacity', 1);
                     componentBox.filter(d => d.id === nodeId).classed('active', true);
                     // Also highlight the corresponding step in the list
                     document.querySelectorAll('.step').forEach((div, stepIndex) => {
                         if (stepIndex === step.step - 1) {
                              div.classList.add('active');
                         } else {
                              div.classList.remove('active');
                         }
                     });

                }, index * 200);
            });

            // Animate links with fade in and flow animation
            activeLinks.forEach((link, index) => {
                setTimeout(() => {
                    d3.selectAll('.link')
                        .filter(d => d.source === link.source && d.target === link.target)
                        .transition()
                        .duration(300)
                        .style('opacity', 1);
                    d3.selectAll('.link').filter(d => d.source === link.source && d.target === link.target).classed('active', true);

                    // Also highlight the corresponding link label
                    d3.selectAll('.link-label')
                         .filter(d => d.source === link.source && d.target === link.target)
                         .classed('active', true);

                }, (activeNodes.length + index) * 200);
            });

            // Update step highlighting with smooth transition (This is now done inside the component animation loop)
            document.querySelectorAll('.step').forEach((div, index) => {
                div.style.transition = 'all 0.3s ease';
                div.className = 'step' + (index === step.step - 1 ? ' active' : '');
            });

            // Scroll to the active step with smooth behavior
            const activeStep = document.querySelector('.step.active');
            if (activeStep) {
                activeStep.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            setTimeout(() => {
                animationInProgress = false;
            }, (activeNodes.length + activeLinks.length) * 200);
        }

        function nextStep() {
            if (currentStep < currentSteps.length - 1) {
                currentStep++;
                highlightStep(currentSteps[currentStep]);
            }
        }

        function previousStep() {
            if (currentStep > 0) {
                currentStep--;
                highlightStep(currentSteps[currentStep]);
            }
        }

        function resetSimulation() {
            currentStep = 0;
            componentBox.classed('active', false);
            link.classed('active', false);
            document.querySelectorAll('.step').forEach(div => {
                div.className = 'step';
            });
        }

        // Add keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowRight') {
                nextStep();
            } else if (event.key === 'ArrowLeft') {
                previousStep();
            } else if (event.key === 'r' || event.key === 'R') {
                resetSimulation();
            }
        });

        // Add touch support for mobile devices
        let touchStartX = 0;
        const architecture = document.getElementById('architecture');

        architecture.addEventListener('touchstart', function(event) {
            touchStartX = event.touches[0].clientX;
        });

        architecture.addEventListener('touchend', function(event) {
            const touchEndX = event.changedTouches[0].clientX;
            const diff = touchStartX - touchEndX;

            if (Math.abs(diff) > 50) {
                if (diff > 0) {
                    nextStep();
                } else {
                    previousStep();
                }
            }
        });

        // Add click event listener to component boxes to open popup
        componentBox.on('click', (event, d) => {
            // Find the corresponding step based on the node's step property
            const step = currentSteps.find(s => s.step === d.step);
            if (step) {
                openPopup(step);
                highlightStep(step); // Also highlight the step in the diagram
            }
        });

        // Process initial text
        processText();
    </script>
</body>
</html> 